모든 출처: 이스트소프트 백엔드 개발자 오르미 5기

# Spring Framework란?

- Java 애플리케이션 개발을 위한 오픈 소스 프레임워크
- 다양한 기능과 라이브러리를 제공함
- 한국에서 Spring = 전자정부표준프레임워크

<aside>
🤔 프레임워크란?
: 애플리케이션의 전체적인 구조를 제공하며, 개발자는 프레임워크가 정의한 규칙과 절차에 따라 코드를 작성해야함
- IoC 구현, 애플리케이션의 주요 흐름 제어, 개발자가 작성한 코드 호출

cf ) **라이브러리**
: 특정 기능을 수행하는 코드의 모음, 개발자가 필요한 기능을 선택하여 사용 가능
- 개발자가 애플리케이션의 흐름을 제어하고, 필요한 시점에 라이브러리의 기능을 호출함

⇒ 라이브러리: 개발자가 필요한 기능을 선택적으로 사용하는 도구
프레임워크: 애플리케이션의 전체적인 구조와 흐름을 제어하는 도구, 일관성과 유지보수성 높은 코드 작성에 도움을 줌

</aside>

## 장, 단점

### 장점

1. **의존성 주입 DI (Dependency Injection)** : 객체 간의 의존성을 관리하여 객체끼리 자동으로 연결해줌
2. **관점 지향 프로그래밍 AOP (Aspect-Oriented Programming)** : 공통적인 기능을 한 곳에서 관리할 수 있도록 도와줌
3. **다양한 모듈과 통합** : 다양한 모듈을 제공하여 원하는 기능을 쉽게 사용 가능
4. **테스트 용이성** : 코드 테스트가 쉽게 도와줌

### 단점

1. **학습 곡선** : 배움의 시간이 오래걸림
2. **복잡성** : 다양한 기능이 있지만 이로 인해 프로젝트가 복잡해질 수 있음
3. **런타임 오버헤드** :  내부적으로 많은 일을 처리하여, 속도 저하가 발생할 가능성이 있음

# vs Spring Boot

- Spring을 더 쉽게 사용할 수 있도록 도와주는 도구
- Spring Boot를 사용함으로써 필요한 라이브러리들이 미리 준비되어 있어 더 빠르게 애플리케이션을 사용할 수 있게 해줌
- 장점
  1. **자동 설정** : 애플리케이션에 필요한 대부분의 설정을 자동으로 해줌
  2. **내장 서버** : 애플리케이션을 실행하기 위한 서버(Tomcat 등)를 내장하고 있음
  3. **의존성 관리** : 필요한 라이브러리 간의 의존성을 자동으로 관리해줌
  4. **프로젝트 구조** : 표준화된 프로젝트 구조를 제공


# Spring Boot 라이브러리(종속성)

1. Lombok
- 자바 클래스에서 반복적으로 작성해야 하는 코드( Getter, Setter, toString, equals, hashCode 등)을 어노테이션을 통해 자동 생성해주는 라이브러리
- 코드의 가독성을 높이고, 반복적으로 작성되는 코드를 줄여줌
- `@Getter, @Setter,  @ToString, @EqualsAndHashCode, @noArgsConstructor, @AllArgsConstructor` 등의 어노테이션 제공
2. Spring Configuration Processor
- 외부 설정 파일( application.properties, application.yml 등)에 정의된 속성을 자바 클래스에 매핑할 때 개발자 경험을 향상시키는 라이브러리
- 외부 설정 파일의 속성에 대한 자동 완성, 문서화, 유효성 검사 등의 기능 존재
- `@ConfigurationProperties` 어노테이션과 함께 사용되어 외부 설정 파일의 속성을 자바 클래스에 매핑 가능
3. Spring Boot DevTools
- 개발자 도구 모음, 애플리케이션 개발 시 생산성을 향상시키는 기능 제공
- 코드 변경 시 자동으로 애플리케이션을 다시 시작하거나 브라우저를 리프레시하는 기능(핫 스와핑)을 제공
- 정적 자원(HTML, CSS, JavaScript 등)의 변경사항을 즉시 반영하여 개발 시 변경 사항을 빠르게 확인 가능하게 도와줌
4. Spring Web
- 웹 애플리케이션 개발을 위한 핵심 기능 제공 라이브러리
- RESTful 웹서비스, MVC 패턴 기반 웹 애플리케이션 개발, HTTP 요청 처리, 응답 생성 등의 기능 포함
- `@RestController, @RequestMapping, @GetMapping, @PostMapping` 등의 어노테이션을 제공하여 웹 요청을 처리하고 응답 생성 가능
5. Thymeleaf
- 자바 기반 웹 애플리케이션에서 사용되는 템플릿 엔진
- HTML 템플릿에 Thymeleaf의 특수한 속성과 식을 사용하여 동적으로 데이터를 바인딩하고 화면을 구성할 수 있음
- 서버 사이드 렌더링을 지원, 자연스러운 템플릿 작성과 유지보수성 제공
- Spring Boot에서는 Thymeleaf를 기본 템플릿 엔진으로 사용할 수 있음, 별도의 설정 없이 바로 사용 가능

# Spring IoC Container ⭐⭐

- InverSion Of Control

  = **제어의 역전**

  = 개발자가 객체를 생성하는 것이 아니라 **개발자가 객체를 요청**하면 **컨테이너에서 객체를 만들어 제공**해줌

- 객체를 생성, 관리
- 장점
  1. **느슨한 결합도** : 객체 간의 의존성을 줄여, 코드 수정이 용이해지고 테스하기 쉬운 코드를 작성할 수 있어짐
  2. **코드 재사용성 증가** : 객체의 생성과 관리를 컨테이너에 맡기면, 같은 객체를 여러 곳에서 쉽게 사용 가능해짐
  3. **개발 생상성 향상** : 객체 관리를 맡김으로써, 개발자는 비즈니스 로직 구현에 더 집중 가능
- 단점
  1. **학습 곡선**
  2. **런타임 오버헤드**
- `@Service` 코드가 달린 클래스에서 생성자를 만들어 `@Repository` 코드가 달린 클래스를 호출 → 생성자에서 클래스를 호출 시,  `new` 키워드가 필요 없어지고 필드에 선언된 클래스는 상수로 선언해도 됨

<aside>
🤔 결합도 짚고 넘어가기!
결합도 : 모듈 또는 컴포넌트 간의 상호 의존성 정도를 나타내는 소프트웨어 척도

1. **강결합 Tight Coupling**
   : 모듈 간의 의존성이 높아, 한 모듈의 변경이 다른 모듈에 영향을 크게 미치는 상태 → 유지보수와 확장이 어려워짐
   : 클래스 내부에서 구현 클래스를 직접 호출

2. **약결합 Loose Coupling**
   : 모듈 간의 의존성이 낮아, 한 모듈의 변경이 다른 모듈에 영향을 적게 미치는 상태 → 유지보수와 확장이 쉬워짐
   : 클래스 내부에서 추상 클래스 / 인터페이스를 이용하여 필드를 생성하고, 생성자를 통해 구현 클래스를 주입받음
   : **유지보수성 향상** (변경의 영향 범위가 제한적), **확장성 증대** (새로운 기능 추가나 기존 모듈 교체 시 영향이 적음), **테스트 용이성** (독립적인 테스트가 가능해짐)
   : 인터페이스, 의존성 주입, IoC 컨테이너 등을 이용하여 약결합 코드 작성

</aside>

# Spring Bean

- IoC 컨테이너에 의해 생성, 관리되는 객체 → `@Component`, `@Service`, `@Repository` 등의 어노테이션을 사용하여 Bean을 정의할 수 있음
- 개발자의 객체 생성과 의존성 관리에 대한 부담을 줄여주고, 코드의 모듈화와 재사용성을 높여줌
- 특징
  - Spring IoC가 **생성** 주체이자 **관리** 주체이기 때문에 생성부터 의존성 주입, 소멸 등의 생명주기를 관리함
  - **싱글턴 패턴** : 애플리케이션 전체에서 단 하나의 인스턴스만 존재
  - **의존성 주입** : 생성자, Setter 메서드, field 주입 등을 통해 다른 Bean을 주입 받을 수 있음

## 싱글톤 패턴 (Singleton) 구현하기 ⭐⭐

- 클래스의 **인스턴스를 오직 하나**만 생성하고, **어디에서든**지 해당 인스턴스에 **접근**할 수 있도록 하는 디자인 패턴
- Bean들은 특별한 Scope를 주지 않는 이상 기본적으로 싱글톤 객체로 동작함
- 인스턴스가 하나이기에 **멀티스레드 환경에서 동시성 이슈**에 주의!! → 두 스레드가 동시에 일어나 혼란을 야기 가능
- 구현 방법 : 이른 초기화, 지연 초기화, 스레트 안전한 지연 초기화, 정적 내부 클래스를 사용한 싱글톤

### 이른 초기화 Eager Initialization

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {
        // private 생성자
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

- 장점
  - 구현이 간단하고 이해하기 쉬움
  - 싱글톤 객체가 클래스 로딩 시점에서 생성되므로 Thread-safe 함
- 단점
  - 싱글톤 객체가 항상 생성되어 불필요한 자원 낭비가 발생할 수 있음

# DI (Dependency Injection) ⭐

- 객체 간의 **의존성을 외부에서 주입**하는 디자인 패턴
- 객체가 직접 다른 객체를 생성하거나 의존성을 관리하는 대신, 외부에서 의존성을 제공 받는 방식임 → 직접 객체를 생성하는 것이 아니라 매개변수로 객체를 받아옴
- Injector = 객체를 주입하는 역할 = 클래스끼리 직접 생성하지 않아도 의존하게 만들어줌
- **어노테이션**을 이용하여 구현
  - `@Component`  → `Bean` 등록
  - `@Autowired` → 스프링 컨테이너에게 해당 객체의 의존성을 자동으로 주입하도록 지시함, 코드의 가독성과 유지보수성 향상됨

    ```java
    @Component
    public class UserService {
        private final UserRepository userRepository;
    
        @Autowired 
        // 객체 생성 시, 해당 타입의 Bean을 찾아서 생성자의 인자로 전달
        public UserService(UserRepository userRepository) { 
            this.userRepository = userRepository;
        }
    }
    
    @Component
    public class UserRepository {
        // ...
    }
    ```

  - 해당 타입의 Bean이 여러 개 존재한다면,

    ```java
    @Component
    public class UserService {
        @Autowired
        @Qualifier("userRepositoryImpl") // 해당 빈을 주입
        private UserRepository userRepository;
        
        // ...
    }
    ```

    <aside>
    🤔 구현체 이름 ≠ 매개변수 이름이면?
    - 의존성 자동 주입이 안됨 → 에러 발생
    - `생성자 (Quarlified(”구현체”) 매개변수)` 로 선언하여 의존성 주입 필수

    </aside>