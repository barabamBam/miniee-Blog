모든 출처: 이스트소프트 백엔드 개발자 오르미 5기

# TDD란?

- 테스트 주도 개발 `Test-Driven Development`
- 소프트웨어 개발 방법론 중 하나로, 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스
- TDD를 이용한 개발 방식: (테스트 작성 → 구현 → 리팩토링) 반복 → 배포

## 작성 순서 및 개념

### **1. 테스트 우선 작성**

추가하고자 하는 기능의 요구사항을 정확히 정의하기

### **2. 작은 단위의 테스트**

하나의 메소드나 기능을 테스트하는 단위 테스트로 실행

### **3. 실패하는 테스트로 시작**

테스트가 의도한 대로 작동하고 있음을 확인하기 위해 반드시 실패하는 테스트로 작성

### **4. 최소한의 코드 작성**

코드의 품질보다는 기능 구현에 집중

### **5. 리팩토링**

테스트 통과 후, 코드 개선 및 중복 제거, 코드의 구조와 가독성을 향상시키려고 노력하는 단계

## TDD 주의 사항

- 아주 작은 단계로 나누어 개발하기
- 현재 필요하지 않은 기능은 만들지 않기 → 테스트와 요구사항에 집중하기 (YAGNI = You Aren’t Gonna Need It)
- 작은 변경사항을 지속적으로 자주 통합하기
- 학습 곡선이 크기 때문에 꾸준한 연습이 필요함
- 테스트 코드도 유지보수가 필요함
- 모든 상황에 적합한 것은 아니기 때문에 프로젝트 성격을 고려하여 작성하기

## TDD의 장점

1. 버그 감소
  - 조기 발견: 버그를 개발 초기 단계에서 발견할 수 있게 됨 → 수정이 더 쉽고 비용도 적게 듦
  - 회귀 버그 방지: 이미 작성된 테스트가 새로운 기능을 추가할 때마다 실행되기 때문에 새 코드가 기존 기능을 망가뜨리지 않았는지 확인이 가능해짐
2. 코드 품질 향상
  - 모듈화: 테스트하기 쉬운 코드를 작성하다 보면 자연스럽게 작고 독립적인 함수나 모듈로 코드가 나뉘게 되어 코드의 재사용성과 유지보수성을 높임
  - 필요한 기능만을 구현하게 되어 불필요한 코드를 줄일 수 있게 됨
3. 명확한 요구사항 정의
  - 테스트 코드는 프로그램이 어떻게 동작해야 하는지를 명확히 명시도록 작성하고, 이는 곧 실행 가능한 요구사항 문서가 됨
  - 테스트 코드를 통해 기능의 정확한 동작을 확인할 수 있게 하고 개발자, 테스터, 기획자 간의 소통을 원할하게 함
4. 설계 개선
  - 테스트 작성 시, 코드의 사용자 입장에서 생각하게 되기 때문에 더 나은  API와 사용하기 쉬운 인터페이스 설계로 이어짐
  - 독립적으로 테스트 가능한 컴포넌트를 만들다 보면 각 부분 간의 결합도가 낮아지고 유연하고 확장 가능한 설계를 만들게 됨
5. 개발 속도 향상
  - 테스트 코드를 처음 작성할 때는 개발 속도가 느려질 수 있으나 숙련도가 높아지면 개발 속도가 빨라짐
  - 문제를 빨리 발견하고 수정할 수 있어 전체적인 개발 시간이 단축됨
6. 안정감과 자신감
  - 광범위한 테스트 덕분에 코드 변경에 대한 두려움이 줄고 리팩토링이나 새 기능 추가 시 더 자신 있게 작업이 가능해짐
  - 코드가 제대로 동작한다는 확신이 스트레스를 줄여줌
7. 문서화 효과
  - 테스트 코드는 프로그램의 동작을 설명하는 최신의 문서 역할을 하기 때문에 새로운 팀원이 프로젝트에 참여할 때 시스템 이해가 용이해짐

## TDD Cycle: Red-Green-Refactor

- 이점: 점진적 개발, 지속적인 피드백, 자신감 있는 리팩토링, 클린 코드 → 안정적이고 유지보수가 쉬운 코드를 개발할 수 있게 됨

### Red

- 실패하는 테스트를 작성하는 단계 (필요한 기능 및 클래스 등이 구현되지 않은 단계)
- **목적**
  구현하고자 하는 기능에 대한 테스트를 먼저 작성하므로 반드시 실패하는 테스트를 작성
- **방법**
  원하는 기능을 정확히 정의하며, 그 기능을 테스트하는 코드를 작성함
- **주의사항**
  테스트는 가능한 작고 간단해야하며, 한 번에 하나의 기능만 테스트함

### Green

- 테스트를 통과하는 최소한의 코드를 작성하는 단계
- **목적**
  이전에 실패하도록 작성한 테스트를 통과시키며, 가능한 가장 간단한 방법으로 구현함
- **방법**
  테스트를 통과할 수 있는 최소한의 코드를 작성하며, 코드의 품질이나 구조는 중요하지 않음
- **주의사항**
  테스트를 통과하는 것에 집중

### Refactor

- 코드를 개선시키는 단계
- **목적**
  중복을 제거하고 코드를 개선하며, 코드의 구조와 가독성을 향상시키도록 노력함
- **방법**
  테스트를 통과한 코드를 검토하여 코드의 구조, 변수명, 함수명 등을 개선하고, 리팩토링 후에도 모든 테스트가 통과하는지 확인함
- **주의사항**
  기능을 변경하지 않고 구조만 개선하며, 리팩토링 후 반드시 모든 테스트를 다시 실행시켜봄

```java
// Red
@Test
void 덧셈_계산() {
	// Calculator 클래스와 add 메서드가 없으므로 반드시 실패함
	Calculator cal = new Calculator();
	int result = cal.add(1,5); 
	// 결과값이 같아야만 하도록 테스트, Assertions.assertEquals 이용
	assertEquals(6, result); 
}

// Green
public class Calculator {
	// 필요한 기능만 젇의하며, 간단하게 확인할 수 있을 정도로만 작성
	public int add(int a, int b) {
		return a+b;
	}
}

// Refactor
public class Calculator {
	// 정의했던 기능의 함수명, 변수명 등을 개선
	public int add(int augend, int addend) {
		return augend+addend;
	}
}
```

# JUnit 5란?

- Java 프로그래밍 언어를 위한 **단위 테스트** 프레임워크
- 구조: JUnit Platform / JUnit Jupiter / JUnit Vintage